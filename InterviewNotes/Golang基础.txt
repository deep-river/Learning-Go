
数组
    Go语言的数组不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组。

    Go中数组赋值和函数传参都是值复制的，传递的是原数组的拷贝。你可以理解为Go语言的数组是一种有序的struct

    问题：如果每次传参都用数组，那么每次数组都要被复制一遍，会消耗掉大量的内存。
    解决方法：函数传参用数组的指针或者切片。

切片
    1. 切片（slice）是对数组一个连续片段的引用，这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。切片本身并不是动态数组或者数组指针。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。

    2. Slice 有三个属性字段：长度、容量和指向数组的指针，数据结构定义如下:
        type slice struct {
            array unsafe.Pointer
            len   int
            cap   int
        }
    Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。

    3. 创建切片有两种形式，make 创建切片，字面量创建切片。
    make创建切片: s := make([]int, 5)
    字面量创建切片: s := []int{1,1,1,1,1}

    4. nil切片与空切片
    nil切片: var s []int
    空切片: s := make([]int, 0)或者s := []int{}

    nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。

    空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。空切片指针不为nil。

    5. 切片扩容
    a. 首先判断，如果新申请容量cap大于2倍的旧容量，最终容量就是新申请的容量。如果旧切片的容量小于1024个元素，那么扩容的时候slice的容量cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一，直到最终容量大于等于新申请的容量。

    b. 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。

    6. 注意的问题
    func main() {
        slice := []int{10, 20, 30, 40}
        for index, value := range slice {
            fmt.Printf("value = %d , value-addr = %x , slice-addr = %x\n", value, &value, &slice[index])
        }
    }
    输出：
    value = 10 , value-addr = c4200aedf8 , slice-addr = c4200b0320
    value = 20 , value-addr = c4200aedf8 , slice-addr = c4200b0328
    value = 30 , value-addr = c4200aedf8 , slice-addr = c4200b0330
    value = 40 , value-addr = c4200aedf8 , slice-addr = c4200b0338

    如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。
    （参考: https://halfrost.com/go_slice/）

Map
    1. Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即哈希桶bucket，而每个bucket就保存了map中的一个或一组键值对。

    2. bucket数据结构由runtime/map.go/bmap定义：
    type bmap struct {
        tophash [8]uint8 //存储哈希值的高8位
        data    byte[1]  //key value数据:key/key/key/.../value/value/value...
        overflow *bmap   //溢出的下一个bucket的地址
    }
    每个bucket可以存储8个键值对。
    tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。
    data区存放的是key-value数据，存放顺序是key/key/key/...value/value/value，如此存放是为了节省字节对齐带来的空间浪费。
    overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。

    3. 哈希冲突
    当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。
    由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。

    4. 负载因子
    负载因子用于衡量一个哈希表冲突情况，公式为：负载因子 = 键数量/bucket数量

    哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：
    哈希因子过小，说明空间利用率低
    哈希因子过大，说明冲突严重，存取效率低

    每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子

    5. Map扩容
    为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。触发扩容的条件有二个：
        1. 负载因子 > 6.5时，也即平均每个bucket存储的键值对达到6.5个。
        2. overflow数量 > 2^15时，也即overflow数量超过32768时。

    6. 增量扩容:
    当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。
    考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。

    7. 等量扩容:
    所谓等量扩容，实际上并不是扩大容量，而是buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。
    在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。

    8. 插入过程:
    新元素插入过程如下：
    1. 根据key值算出哈希值
    2. 取哈希值低位与hmap.B取模确定bucket位置
    3. 查找该key是否已经存在，如果存在则直接更新值
    4. 如果没找到将key，将key插入
    (参考: https://blog.csdn.net/qq_38572383/article/details/95359805)

    9. go语言1.9之前map都是并发/协程不安全的。Go 1.9 以后官方给出了sync.Map 同步map。内部基于锁实现协程安全。
    type Map struct {
        mu Mutex
        read atomic.Value // readOnly
        dirty map[interface{}]*entry
        misses int
    }
    互斥量 mu 保护 read 和 dirty。

堆与栈/内存逃逸
    栈
    在程序中，每个函数块都会有自己的内存区域用来存自己的局部变量（内存占用少）、返回地址、返回值之类的数据，这一块内存区域有特定的结构和寻址方式，寻址起来十分迅速，开销很少。这一块内存地址称为栈。栈是一种后入先出的结构。栈是线程级别的，大小在创建的时候已经确定，当变量太大的时候，会"逃逸"到堆上，这种现象称为内存逃逸。简单来说，局部变量通过堆分配和回收，就叫内存逃逸。

    堆与栈的区别:
    1. 栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放。
    2. 栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。
    3. 栈的访问速度相对比堆快。
    4. 一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack 是线程独占的，heap 是线程共用的。
    5. stack 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap的大小是不确定的，需要的话可以不断增加。
    6. 栈是由高地址向低地址增长的，而堆是由低地址向高地址增长的。

    Go的堆栈
    Go 是自己管理内存的，而不是交给操作系统，它每次从操作系统申请一大块内存，然后按照 Google 的 TCMalloc 算法进行内存分配，也划分为堆、栈等很多区域。

    Go中变量分配在堆还是栈由编译器确定
    变量究竟放在堆还是栈里，官方有这么一段解释:
    1. 只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。
    2. 在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。
    3. 总之，分配在堆还是栈完全由编译器确定。

    内存逃逸发生时机/典型情况:
    1. 向 channel 发送指针数据。因为在编译时，不知道channel中的数据会被哪个 goroutine 接收，因此编译器没法知道变量什么时候才会被释放，因此只能放入堆中。
    2. 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，因此只能放入堆中。
    3. 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
    4. 切片扩容后长度太大，导致栈空间不足，逃逸到堆上。
    5. 在 interface 类型上调用方法。 在 interface 类型上调用方法时会把interface变量使用堆分配， 因为方法的真正实现只能在运行时知道。

    避免内存逃逸的办法:
    1. 对于小型的数据，使用传值而不是传指针，避免内存逃逸。
    2. 避免使用长度不固定的slice切片，在编译期无法确定切片长度，只能将切片使用堆分配。
    3. interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。