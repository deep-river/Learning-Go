什么是面向对象
    在了解 Go 语言是不是面向对象（简称：OOP） 之前，我们必须先知道 OOP 是啥，得先给他 “下定义”。

    根据 Wikipedia 的定义，我们梳理出 OOP 的几个基本认知：
        面向对象编程（OOP）是一种基于 "对象" 概念的编程范式，它可以包含数据和代码：数据以字段的形式存在（通常称为属性或属性），代码以程序的形式存在（通常称为方法）。
        对象自己的程序可以访问并经常修改自己的数据字段。
        对象经常被定义为类的一个实例。
        对象利用属性和方法的私有/受保护/公共可见性，对象的内部状态受到保护，不受外界影响（被封装）。

    基于这几个基本认知进行一步延伸出，面向对象的三大基本特性：
        封装。
        继承。
        多态。


Golang 面向对象编程
    go语言中，虽然没有明确提出面向对象的概念，但是基于已有的语法设计，我们也可以写出面向对象的代码。go语言中的面向对象是借助struct结构体实现的。值得一提的是，go语言中虽然没有class关键字来表示类，但却有interface来表示接口。

    封装
        面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用，这样子用户就不需要关注你内部是怎么实现的。

        在 Go 语言中的属性访问权限，通过首字母大小写来控制：
            首字母大写，代表是公共的、可被外部访问的。
            首字母小写，代表是私有的，不可以被外部访问。

    继承
        在 Go 语言中，是没有类似 extends 关键字的这种继承的方式，在语言设计上采取的是组合的方式：
            type Animal struct {
            Name string
            }

            type Cat struct {
            Animal
            FeatureA string
            }

            type Dog struct {
            Animal
            FeatureB string
            }
        在上述例子中，我们声明了 Cat 和 Dog 结构体，其在内部匿名组合了 Animal 结构体。因此 Cat 和 Dog 的实例都可以调用 Animal 结构体的方法：

    多态 
        面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力，具体是指一个类实例（对象）的相同方法在不同情形有不同表现形式。
        多态也使得不同内部结构的对象可以共享相同的外部接口，也就是都是一套外部模板，内部实际是什么，只要符合规格就可以。
        在 Go 语言中，多态是通过接口来实现的：结构体中只要有和接口中定义的同名方法，就称该结构体是实现了哪个接口。

            type AnimalSounder interface {
            MakeDNA()
            }

            func MakeSomeDNA(animalSounder AnimalSounder) {
            animalSounder.MakeDNA()
            }
        在上述例子中，我们声明了一个接口类型 AnimalSounder，配套一个 MakeSomeDNA 方法，其接受 AnimalSounder 接口类型作为入参。

        因此在 Go 语言中。只要配套的 Cat 和 Dog 的实例也实现了 MakeSomeDNA 方法，那么我们就可以认为他是 AnimalSounder 接口类型：

            type AnimalSounder interface {
            MakeDNA()
            }

            func MakeSomeDNA(animalSounder AnimalSounder) {
            animalSounder.MakeDNA()
            }

            func (c *Cat) MakeDNA() {
            fmt.Println("煎鱼是煎鱼")
            }

            func (c *Dog) MakeDNA() {
            fmt.Println("煎鱼其实不是煎鱼")
            }

            func main() {
            MakeSomeDNA(&Cat{})
            MakeSomeDNA(&Dog{})
            }
        当 Cat 和 Dog 的实例实现了 AnimalSounder 接口类型的约束后，就意味着满足了条件，他们在 Go 语言中就是一个东西。能够作为入参传入 MakeSomeDNA 方法中，再根据不同的实例实现多态行为。

传参
    在Go语言中有五个引用类型变量,其他都是值类型
        slice
        map
        channel
        interface
        func()
    引用类型作为参数时,称为浅拷贝,形参改变,实参数跟随变化.因为传递的是地址,形参和实参都指向同一块地址
    值类型作为参数时,称为深拷贝,形参改变,实参不变,因为传递的是值的副本,形参会新开辟一块空间,与实参指向不同
    如果希望值类型数据在修改形参时实参跟随变化,可以把参数设置为指针类型

数组
    Go语言的数组不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组。

    Go中数组赋值和函数传参都是值复制的，传递的是原数组的拷贝。你可以理解为Go语言的数组是一种有序的struct

    问题：如果每次传参都用数组，那么每次数组都要被复制一遍，会消耗掉大量的内存。
    解决方法：函数传参用数组的指针或者切片。

切片
    1. 切片（slice）是对数组一个连续片段的引用，这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。切片本身并不是动态数组或者数组指针。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。

    2. Slice 有三个属性字段：长度、容量和指向数组的指针，数据结构定义如下:
        type slice struct {
            array unsafe.Pointer
            len   int
            cap   int
        }
    Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。

    3. 创建切片有两种形式，make 创建切片，字面量创建切片。
    make创建切片: s := make([]int, 5)
    字面量创建切片: s := []int{1,1,1,1,1}

    4. nil切片与空切片
    nil切片: var s []int
    空切片: s := make([]int, 0)或者s := []int{}

    nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。

    空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。空切片指针不为nil。

    5. 切片扩容
    a. 首先判断，如果新申请容量cap大于2倍的旧容量，最终容量就是新申请的容量。如果旧切片的容量小于1024个元素，那么扩容的时候slice的容量cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一，直到最终容量大于等于新申请的容量。

    b. 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。

    6. 注意的问题
    func main() {
        slice := []int{10, 20, 30, 40}
        for index, value := range slice {
            fmt.Printf("value = %d , value-addr = %x , slice-addr = %x\n", value, &value, &slice[index])
        }
    }
    输出：
    value = 10 , value-addr = c4200aedf8 , slice-addr = c4200b0320
    value = 20 , value-addr = c4200aedf8 , slice-addr = c4200b0328
    value = 30 , value-addr = c4200aedf8 , slice-addr = c4200b0330
    value = 40 , value-addr = c4200aedf8 , slice-addr = c4200b0338

    如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。
    （参考: https://halfrost.com/go_slice/）

Map
    1. Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即哈希桶bucket，而每个bucket就保存了map中的一个或一组键值对。

    2. bucket数据结构由runtime/map.go/bmap定义：
    type bmap struct {
        tophash [8]uint8 //存储哈希值的高8位
        data    byte[1]  //key value数据:key/key/key/.../value/value/value...
        overflow *bmap   //溢出的下一个bucket的地址
    }
    每个bucket可以存储8个键值对。
    tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。
    data区存放的是key-value数据，存放顺序是key/key/key/...value/value/value，如此存放是为了节省字节对齐带来的空间浪费。
    overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。

    3. 哈希冲突
    当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。
    由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。

    4. 负载因子
    负载因子用于衡量一个哈希表冲突情况，公式为：负载因子 = 键数量/bucket数量

    哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：
    哈希因子过小，说明空间利用率低
    哈希因子过大，说明冲突严重，存取效率低

    每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子

    5. Map扩容
    为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。触发扩容的条件有二个：
        1. 负载因子 > 6.5时，也即平均每个bucket存储的键值对达到6.5个。
        2. overflow数量 > 2^15时，也即overflow数量超过32768时。

    6. 增量扩容:
    当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。
    考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。

    7. 等量扩容:
    所谓等量扩容，实际上并不是扩大容量，而是buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。
    在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。

    8. 插入过程:
    新元素插入过程如下：
    1. 根据key值算出哈希值
    2. 取哈希值低位与hmap.B取模确定bucket位置
    3. 查找该key是否已经存在，如果存在则直接更新值
    4. 如果没找到将key，将key插入
    (参考: https://blog.csdn.net/qq_38572383/article/details/95359805)

    9. sync.Map是在Go 1.9版本中增加的支持并发安全的Map。
    go语言1.9之前map都是并发/协程不安全的。Go 1.9 以后官方给出了sync.Map 同步map。内部基于锁实现协程安全。
    type Map struct {
        mu Mutex
        read atomic.Value // readOnly
        dirty map[interface{}]*entry
        misses int
    }
    互斥量 mu 保护 read 和 dirty。

堆与栈/内存逃逸
    栈
    在程序中，每个函数块都会有自己的内存区域用来存自己的局部变量（内存占用少）、返回地址、返回值之类的数据，这一块内存区域有特定的结构和寻址方式，寻址起来十分迅速，开销很少。这一块内存地址称为栈。栈是一种后入先出的结构。栈是线程级别的，大小在创建的时候已经确定，当变量太大的时候，会"逃逸"到堆上，这种现象称为内存逃逸。简单来说，局部变量通过堆分配和回收，就叫内存逃逸。

    堆与栈的区别:
    1. 栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放。
    2. 栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。
    3. 栈的访问速度相对比堆快。
    4. 一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack 是线程独占的，heap 是线程共用的。
    5. stack 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap的大小是不确定的，需要的话可以不断增加。
    6. 栈是由高地址向低地址增长的，而堆是由低地址向高地址增长的。

    Go的堆栈
    Go 是自己管理内存的，而不是交给操作系统，它每次从操作系统申请一大块内存，然后按照 Google 的 TCMalloc 算法进行内存分配，也划分为堆、栈等很多区域。

    Go中变量分配在堆还是栈由编译器确定
    变量究竟放在堆还是栈里，官方有这么一段解释:
    1. 只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。
    2. 在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。
    3. 总之，分配在堆还是栈完全由编译器确定。

    内存逃逸发生时机/典型情况:
    1. 向 channel 发送指针数据。因为在编译时，不知道channel中的数据会被哪个 goroutine 接收，因此编译器没法知道变量什么时候才会被释放，因此只能放入堆中。
    2. 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，因此只能放入堆中。
    3. 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
    4. 切片扩容后长度太大，导致栈空间不足，逃逸到堆上。
    5. 在 interface 类型上调用方法。 在 interface 类型上调用方法时会把interface变量使用堆分配， 因为方法的真正实现只能在运行时知道。

    避免内存逃逸的办法:
    1. 对于小型的数据，使用传值而不是传指针，避免内存逃逸。
    2. 避免使用长度不固定的slice切片，在编译期无法确定切片长度，只能将切片使用堆分配。
    3. interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。

乐观锁/悲观锁
    改变一个数值的三个步骤：
    ①把想修改的数值从某个地方取出来；②在取出来的数值修改为期望值；③把修改后的数值保存到原来的地方。

    悲观锁
    悲观的锁总认为会发生并发问题。
    拿数据的时候都认为在使用过程中，别人会修改它，所以一开始就会上锁，别人想拿该数据就会阻塞，直到获取到锁。
    上面的过程即是悲观锁，总是存在加锁和解除锁的动作。

    乐观锁
    乐观的锁总认为不会发生并发问题。
    拿数据的时候都认为在使用该数据的过程中，别人不会修改它，所以在此过程中不会上锁。而当更新数据之后，会判断在此期间有没有其他人更改这个数据。
    不加锁，正常进行①②步，在进行③的时候，确认一下数值是否进行了修改，如果被修改过，放弃修改，重新走一遍①②③（或者放弃对数值进行修改）。
    上面的过程即是乐观锁，不存在加锁和解除锁的动作。

    乐观锁与悲观锁对比
    1. 乐观锁没有加锁和解除锁的步骤，直觉上会快一些；但是乐观锁这么做的前提是总认为不会发生并发，如果并发发生的概率很大，重试的次数会增加，这种情况下乐观锁的性能就差很多了。（适用于多读的类型，可以提高吞吐量。）
    2. 悲观锁有加锁和解除锁的步骤，直觉上会慢一些；但是当有很多进程或者线程对同一个数值进行修改时，能避免大量的重试过程，这种情况下悲观锁的性能相对就很高了。（适用于多写的场景，不会像乐观锁那样出现很多冲突。）

    Golang中的乐观锁与悲观锁 atomic/sync
    1. Golang中有一个 atomic 包，可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，这个包应用的便是乐观锁的原理。不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）
    2. Golang中的sync包，提供了各种锁，如果使用了这个包，基本上就以悲观锁的工作模式了。

互斥锁
    Go语言在Mutex包中提供了互斥锁，sync.Mutex

    Go语言的sync.Mutex由两个字段组成
    type Mutex struct {
        state int32
        sema  int32
    }
    其中Mutex.state表示了当前互斥锁处于的状态
        waiterNum 表示目前互斥锁等待队列中有多少goroutine在等待
        straving 表示目前互斥锁是否处于饥饿状态
        woken 表示目前互斥锁是否为唤醒状态
        locked 表示目前互斥锁资源是否被goroutine持有
    而Mutex.sema主要用于等待队列

    互斥锁通常保持两种状态 正常模式 与 饥饿模式
    引入饥饿模式的原因是，为了保持互斥锁的公平性。
    在正常模式下，锁资源一般会交给刚被唤醒的goroutine，而为了怕部分goroutine被“饿死”，所以引入了饥饿模式，在饥饿模式下，goroutine在释放锁资源的时候会将锁资源交给等待队列中的下一个goroutine。

    参考链接: https://zhuanlan.zhihu.com/p/152214855

CAS
    CAS指的是CompareAndSwap，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 
    
    该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。

    CAS的缺陷:
        1. CAS在共享资源竞争比较激烈的时候，每个goroutine会容易处于自旋状态，影响效率，在竞争激烈的时候推荐使用锁。
        2. 无法解决ABA问题

    ABA问题是无锁结构实现中常见的一种问题，可基本表述为：
        进程P1读取了一个数值A
        P1被挂起(时间片耗尽、中断等)，进程P2开始执行
        P2修改数值A为数值B，然后又修改回A
        P1被唤醒，比较后发现数值A没有变化，程序继续执行。

RPC
    远程过程调用（Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。RPC允许跨机器、跨语言调用计算机程序方法。

    golang官方的net/rpc库使用encoding/gob进行编解码，支持tcp和http数据传输方式，由于其他语言不支持gob编解码方式，所以golang的RPC只支持golang开发的服务器与客户端之间的交互

    官方还提供了net/rpc/jsonrpc库实现RPC方法，jsonrpc采用JSON进行数据编解码，因而支持跨语言调用，目前jsonrpc库是基于tcp协议实现的，暂不支持http传输方式

    golang写RPC程序，必须符合4个基本条件
        结构体字段首字母要大写，可以别人调用
        函数名必须首字母大写
        函数第一参数是接收参数，第二个参数是返回给客户端的参数，必须是指针类型
        函数还必须有一个返回值error

Raft
    Raft是一个分布式的一致性协议算法，通过 选主机制 和 日志状态机模型 来保证分布式系统的数据强一致性。

    在Raft协议里，系统中的所有节点中必须选出一个Leader。
    为什么要有leader?
        因为分布式的数据分区特性，如果没有Leader来协调数据处理，就很难保证数据是一致的了。
        如果没有Leader，则系统的每次操作都要进行一次投票，开销非常大。Paxos算法也是一个分布式一致性协议，使用P2P算法来保证，但是实际理解和实现都过于复杂。如果有一个leader会让决策变得简单快速。

    Raft 集群中每个节点都处于以下三种角色之一：
        Leader: 所有请求的处理者，接收客户端发起的操作请求，写入本地日志后同步至集群其它节点。
        Follower: 请求的被动更新者，从 leader 接收更新请求，写入本地文件。如果客户端的操作请求发送给了 follower，会首先由 follower 重定向给 leader。
        Candidate: 如果 follower 在一定时间内没有收到 leader 的心跳，则判断 leader 可能已经故障，此时启动 leader election 过程，本节点切换为 candidate 直到选主结束。

    分布式要保证可用性，往往意味着多副本存储，且各副本节点的数据一致；Raft维持多副本数据一致的方式是使用日志状态机。
    日志状态机通过二元组(index,term)来作为日志状态向量。
        index是连续递增的数字，是日志的逻辑序号，各个副本上相同的index，有相同的数据日志。
        term任期也是连续递增的数字，如上面解释的那样，一个term则表示某个节点当选的一段时间。

    Leader election (领导选举)
        Raft 使用一种心跳机制来触发领导人选举:
        1. 当服务器程序启动时，节点都是 follower(跟随者) 身份
        2. 如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者
        3. 要开始一次选举过程，follower 会给当前term加1并且转换成candidate状态，然后它会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。
        4. 候选人的状态维持直到发生以下任何一个条件发生的时候
            1. 他自己赢得了这次的选举
            2. 其他的服务器成为领导者
            3. 一段时间之后没有任何一个获胜的人

    Log replication (日志复制)
        当选出 leader 后，它会开始接收客户端请求，每个请求会带有一个指令，可以被回放到状态机中
        leader 把指令追加成一个log entry，然后通过AppendEntries RPC并行地发送给其他的server，当该entry被多数server复制后，leader 会把该entry回放到状态机中，然后把结果返回给客户端
        当 follower 宕机或者运行较慢时，leader 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry
        raft的log replication要保证如果两个log entry有相同的index和term，那么它们存储相同的指令
        leader在一个特定的term和index下，只会创建一个log entry

    Raft系统采用RPC心跳来通信,主要有两种类型的RPC：

        AppendEntries:
        用于Leader向其他Follower同步日志数据
        维护和Followers的心跳

        RequestVote：Candidate调用的请求用于获取投票