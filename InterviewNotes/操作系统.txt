linux使用的进程间通信方式
    管道（pipe）,流管道(s_pipe)和有名管道（FIFO）
    信号（signal）
    消息队列
    共享内存
    信号量
    套接字（socket)

进程间8种通信方式：
    匿名管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
    有名管道 (named pipe)： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
    消息队列(message queue)：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    信号量( semophore )： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    套接字( socket )： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

进程与线程、协程
    什么是进程。最直观的就是一个个pid，官方的说法就：进程是程序在计算机上的一次执行活动。

    线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。

    线程共享内存空间（共享数据等），进程的内存空间是独立的
    同一进程的线程之间可以相互交流 ，2个进程之间的交流必须通过一个中间代理

    协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈

LRU
    一种指定容量的存储结构，当内存中数据到达指定容量的时候，LRU选择将最长时间没有被使用过的那个键值对从内存中移除。
    整体的设计思路是，可以使用 HashMap 存储 key，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap的Value指向双向链表实现的LRU的Node节点。每次读取数据时将最近被访问的数据移向双向链表的表头，如果容量满了同时删除尾部的节点。

堆和栈：
    C++
    在C++中，内存分为5个区：堆、栈、自由存储区、全局/静态存储区、常量存储区

    栈：是由编译器在需要时自动分配，不需要时自动清除的变量存储区（系统分配，系统释放）。通常存放局部变量、函数参数等。

    堆：是由new分配的内存块，由用户自己释放，一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。

    自由存储区：是由malloc等分配的内存块，和堆十分相似，用free来释放。
    全局/静态存储区：全局变量和静态变量被分配到同一块内存中（在C语言中，全局变量又分为初始化的和未初始化的，C++中没有这一区分）。
    常量存储区：这是一块特殊存储区，里边存放常量，不允许修改

    栈的内存分配释放速度快，效率高，内存都是连续的
    堆内存的分配释放相对来说效率低一些，内存不一定连续，容易产生内存碎片，但灵活性高

    栈是由高地址像低地址扩展的连续内存，栈的大小一般为2M或者10M
    堆是由低地址向高地址扩展的非连续内存，堆的大小影响因素较多，和系统虚拟地址内存的大小有关。

对于malloc和free的操作有以下规则：
1)配对使用，有一个malloc，就应该有一个free。（C++中对应为new和delete）
2) 尽量在同一层上使用，不要malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。
3) malloc分配的内存一定要初始化，free后的指针一定要设置为NULL。