编译型语言
    用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统（不仅仅只是通过编译器，编译器只是编译系统的一部分）把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件

解释型语言
    使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。

Python解释器种类以及特点
    Cpython，这个解释器是用C语言开发的，所以叫CPython，CPython是使用最广的Python解释器。
    PyPy，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。
    Jython，Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行

lambda表达式
    lambda表达式也叫匿名函数，即函数没有具体的名称。lambda表达式是python中一类特殊的定义函数的形式。Python的lambda表达式只能有单独的一条语句，也就是返回值表达式语句。让代码更加简洁。一般的形式是：关键词lambda后面紧接一个或多个参数，紧接一个冒号“：”，紧接一个表达式。

装饰器
    Python的装饰器本质上是一个嵌套函数，它接受被装饰的函数(func)作为参数，并返回一个包装过的函数对象。这样我们可以在不改变被装饰函数的代码的情况下给被装饰函数或程序添加新的功能。

闭包
    闭包是Python编程一个非常重要的概念。如果一个外函数中定义了一个内函数，且内函数体内引用到了体外的变量，这时外函数通过return返回内函数的引用时，会把定义时涉及到的外部引用变量和内函数打包成一个整体（闭包）返回。通过简单的@装饰符，增加一个函数的重用性。

如何在Python中管理内存？
    1. python中的内存管理由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。
    2. Python对象的堆空间分配由Python的内存管理器完成。核心API提供了一些程序员编写代码的工具。
    3. Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。

Python中的垃圾回收是以引用计数为主，标记-清除和分代回收为辅。
    引用计数：Python在内存中存储每个对象的引用计数，如果计数变成0，该对象就会消失，分配给该对象的内存就会释放出来。

    标记-清除：一些容器对象，比如list、dict、tuple，instance等可能会出现引用循环，对于这些循环，垃圾回收器会定时回收这些循环（对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边）。

    分代收集：Python把内存根据对象存活时间划分为三代，对象创建之后，垃圾回收器会分配它们所属的代。每个对象都会被分配一个代，而被分配更年轻的代是被优先处理的，因此越晚创建的对象越容易被回收。

如何在Python中实现多线程？
    Python有一个多线程库，但是用多线程来加速代码的效果并不是那么的好，Python有一个名为Global Interpreter Lock全局解释器锁（GIL）的结构。GIL确保每次只能执行一个“线程”。一个线程获取GIL执行相关操作，然后将GIL传递到下一个线程。

    虽然看起来程序被多线程并行执行，但它们实际上只是轮流使用相同的CPU核心。所有这些GIL传递都增加了程序执行的内存压力。这意味着多线程并不能让程序运行的更快。

    应采用多进程或协程处理并发任务，python中的多进程主要使用到 multiprocessing 这个库

深拷贝和浅拷贝之间的区别是什么？
    深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝。

    而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。

列表和元组之间的区别是？
    二者的主要区别是列表是可变的，而元组是不可变的。

什么是Flask？
    Flask是Python编写的一款轻量级Web应用框架。其WSGI工具箱采用Werkzeug，模板引擎则使用Jinja2。Flask使用BSD授权。其中两个环境依赖是Werkzeug和jinja2，这意味着它不需要依赖外部库。正因如此，我们将其称为轻量级框架。
    Flask会话使用签名cookie让用户查看和修改会话内容。它会记录从一个请求到另一个请求的信息。不过，要想修改会话，用户必须有密钥Flask.secret_key。

Python命名空间
    命名空间是一个命名系统，用于确保名称是唯一性，以避免命名冲突。命名空间是一个字典（dictionary），它的键就是变量名，它的值就是那些变量的值。 在一个 Python 程序中的任何一个地方，都存在几个可用的命名空间。

    1. 每个函数都有着自已的命名空间，叫做局部命名空间，它记录了函数的变量，包括函数的参数和局部定义的变量。
    2. 每个模块拥有它自已的命名空间，叫做全局命名空间，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
    3. 还有就是内置命名空间，任何模块均可访问它，它存放着内置的函数和异常。
    各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。

当一行代码要使用变量x的值时，Python会到所有可用的名字空间去查找变量，Python的查找顺序为：局部的命名空间去 -> 全局命名空间 -> 内置命名空间。
    1. 局部命名空间：特指当前函数或类的方法。如果函数定义了一个局部变量 x，或一个参数 x，Python 将使用它，然后停止搜索。
    2. 全局命名空间：特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用它然后停止搜索。
    3. 内置命名空间：对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。
    4. 如果 Python 在这些名字空间找不到 x，它将放弃查找并引发一个 NameError 异常，如，NameError: name 'aa' is not defined。

Mapping
    mapping类型的数据就是元素为(x,y)的列表，通过dict函数直接可生成以key为x， value为y的字典对象。

SQLAlchemy映射原理
    以前SQLAlchemy是怎么把Python对象和数据库中表里面的每条记录进行映射的呢？通过一个mapping函数。在python里定义table即对应表的结构,class即映射后类，利用mapper函数进行映射关联后，通过query查询返回的结果，会自动将返回结果构造成一个对象，对象的每个属性对应表中的列。

    而新的ORM映射不需要手动通过mapping函数来关联table与类之间的关系，可以直接通过声明（Declarative）系统（我不知道这样翻译对不对）来定义一个类，这个类会直接映射到数据库的表，declarative把Table、mapper、还有类这三者放在类的定义里进行声明，从而实现了ORM的映射。不需要在python里预先定义table的结构还有用mapper关联。背后的操作都是通过一个declarative_base 工厂方法构造的声明系统完成的。